// --- HYPER GENERATED CODE %VERSION% 1644756134 ---
//
// WARNING
//
// This file was automatically generated by the Hyper Platform.
// Manual changes MUST NOT be made, consult documentation at hyper.ag for more
// information.

#ifndef __DATABAY_DEVICE_1000__
#define __DATABAY_DEVICE_1000__

#include <stdint.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include "cmp.h"

// Allow overriding printf.
#ifndef DATABAY_PRINTF
#include <stdio.h>
#define DATABAY_PRINTF(...) printf(__VA_ARGS__)
#endif

#ifndef __DATABAY_DEVICE_HELPERS__
#define __DATABAY_DEVICE_HELPERS__

typedef enum
{
  DATABAY_OK = 0,
  DATABAY_ERR_ATTRIBUTE_SET,
  DATABAY_ERR_ENCODE,
  DATABAY_ERR_DECODE,
} databay_result_t;

typedef struct
{
  uint8_t *data;
  size_t offset;
} databay_msgpack_buffer_t;

static bool databay_device_msgpack_reader(cmp_ctx_t *ctx, void *data, size_t count)
{
  databay_msgpack_buffer_t *msgpack_buf = ctx->buf;
  memcpy(data, msgpack_buf->data + msgpack_buf->offset, count);
  msgpack_buf->offset += count;
  return true;
}

// __unused static bool databay_device_msgpack_skipper(cmp_ctx_t *ctx, size_t count)
// {
//   databay_msgpack_buffer_t *msgpack_buf = ctx->buf;
//   msgpack_buf->offset += count;
//   return true;
// }

static size_t databay_device_msgpack_writer(cmp_ctx_t *ctx, const void *data,
                                     size_t count)
{
  databay_msgpack_buffer_t *msgpack_buf = ctx->buf;
  memcpy(msgpack_buf->data + msgpack_buf->offset, data, count);
  msgpack_buf->offset += count;

  return count;
}

#endif // __DATABAY_DEVICE_HELPERS__

// --- DEVICE TYPE ---
typedef struct
{
  int64_t schema_id;
  bool temperature_set : 1;
  double temperature;
  bool button_set : 1;
  bool button;
  bool led_red_set : 1;
  bool led_red;
  bool led_green_set : 1;
  bool led_green;
  bool uptime_set : 1;
  int64_t uptime;
  bool publish_interval_set : 1;
  int64_t publish_interval;

  void (*on_led_red_update)(bool);
  void (*on_led_green_update)(bool);
  void (*on_publish_interval_update)(int64_t);
} databay_device_1000_t;

void databay_device_1000_reset(databay_device_1000_t *device)
{
  device->temperature_set = false;
  device->temperature = 0.0;
  device->button_set = false;
  device->button = false;
  device->led_red_set = false;
  device->led_red = 0.0;
  device->led_green_set = false;
  device->led_green = 0.0;
  device->uptime_set = false;
  device->uptime = 0;
  device->publish_interval_set = false;
  device->publish_interval = 0;
}

void databay_device_1000_init(databay_device_1000_t *device)
{
  device->schema_id = 1000;
  databay_device_1000_reset(device);
  device->on_led_red_update = NULL;
  device->on_led_green_update = NULL;
  device->on_publish_interval_update = NULL;
}

// --- PRINT DEVICE ---
void databay_device_1000_print(databay_device_1000_t *device)
{
  DATABAY_PRINTF(
      "(databay_device_1000_t\n"
      "  (schema_id %lld)\n",
      (long long int)device->schema_id);

  if (device->temperature_set)
  {
    DATABAY_PRINTF("  (temperature (Float %lf))\n", (double)device->temperature);
  }
  else
  {
    DATABAY_PRINTF("  (temperature (Float none))\n");
  }

  if (device->button_set)
  {
    DATABAY_PRINTF("  (button (Bool %s))\n", device->button ? "true" : "false");
  }
  else
  {
    DATABAY_PRINTF("  (button (Bool none))\n");
  }

  if (device->led_red_set)
  {
    DATABAY_PRINTF("  (led_red (Bool %s))\n", device->led_red ? "true" : "false");
  }
  else
  {
    DATABAY_PRINTF("  (led_red (Bool none))\n");
  }

  if (device->led_green_set)
  {
    DATABAY_PRINTF("  (led_green (Bool %s))\n", device->led_green ? "true" : "false");
  }
  else
  {
    DATABAY_PRINTF("  (led_green (Bool none))\n");
  }

  if (device->uptime_set)
  {
    DATABAY_PRINTF("  (uptime (Int %lld))\n", (long long int)device->uptime);
  }
  else
  {
    DATABAY_PRINTF("  (uptime (Int none))\n");
  }

  if (device->publish_interval_set)
  {
    DATABAY_PRINTF("  (publish_interval (Int %lld))\n", (long long int)device->publish_interval);
  }
  else
  {
    DATABAY_PRINTF("  (publish_interval (Int none))\n");
  }
  DATABAY_PRINTF(")\n");
}

// --- BIND ATTRIBUTES ---
void databay_device_1000_bind_led_red(databay_device_1000_t *device, void (*callback)(bool))
{
  device->on_led_red_update = callback;
}

void databay_device_1000_bind_led_green(databay_device_1000_t *device, void (*callback)(bool))
{
  device->on_led_green_update = callback;
}

void databay_device_1000_bind_publish_interval(databay_device_1000_t *device, void (*callback)(int64_t))
{
  device->on_publish_interval_update = callback;
}

// --- SET ATTRIBUTES ---
void databay_device_1000_set_temperature(databay_device_1000_t *device, double value)
{
  device->temperature_set = true;
  device->temperature = value;
}

void databay_device_1000_set_button(databay_device_1000_t *device, bool value)
{
  device->button_set = true;
  device->button = value;
}

void databay_device_1000_set_led_red(databay_device_1000_t *device, bool value)
{
  device->led_red_set = true;
  device->led_red = value;
}

void databay_device_1000_set_led_green(databay_device_1000_t *device, bool value)
{
  device->led_green_set = true;
  device->led_green = value;
}

void databay_device_1000_set_uptime(databay_device_1000_t *device, int64_t value)
{
  device->uptime_set = true;
  device->uptime = value;
}

void databay_device_1000_set_publish_interval(databay_device_1000_t *device, int64_t value)
{
  device->publish_interval_set = true;
  device->publish_interval = value;
}

// --- ENCODE DEVICE ---
databay_result_t databay_device_1000_encode(databay_device_1000_t *device, uint8_t *out, uint8_t *out_len)
{
  cmp_ctx_t cmp_ctx = {0};
  databay_msgpack_buffer_t msgpack_buf = {out, 0};

  cmp_init(&cmp_ctx, (void *)&msgpack_buf, NULL, NULL, databay_device_msgpack_writer);

  // Encode message as array of elements.
  if (!cmp_write_array(&cmp_ctx, 2))
  {
    DATABAY_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
    return DATABAY_ERR_ENCODE;
  }

  // Device info.
  if (!cmp_write_integer(&cmp_ctx, device->schema_id))
  {
    DATABAY_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
    return DATABAY_ERR_ENCODE;
  }

  uint8_t defined_attributes_count = 0;
  if (device->temperature_set)
    ++defined_attributes_count;
  if (device->button_set)
    ++defined_attributes_count;
  if (device->led_red_set)
    ++defined_attributes_count;
  if (device->led_green_set)
    ++defined_attributes_count;
  if (device->uptime_set)
    ++defined_attributes_count;
  if (device->publish_interval_set)
    ++defined_attributes_count;

  // Attributes
  if (!cmp_write_map(&cmp_ctx, defined_attributes_count))
  {
    DATABAY_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
    return DATABAY_ERR_ENCODE;
  }

  // 0: temperature
  if (device->temperature_set)
  {
    if (!cmp_write_u8(&cmp_ctx, 0))
    {
      DATABAY_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return DATABAY_ERR_ENCODE;
    }
    if (!cmp_write_decimal(&cmp_ctx, device->temperature))
    {
      DATABAY_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return DATABAY_ERR_ENCODE;
    }
  }

  // 1: button
  if (device->button_set)
  {
    if (!cmp_write_u8(&cmp_ctx, 1))
    {
      DATABAY_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return DATABAY_ERR_ENCODE;
    }
    if (!cmp_write_bool(&cmp_ctx, device->button))
    {
      DATABAY_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return DATABAY_ERR_ENCODE;
    }
  }

  // 2: led_red
  if (device->led_red_set)
  {
    if (!cmp_write_u8(&cmp_ctx, 2))
    {
      DATABAY_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return DATABAY_ERR_ENCODE;
    }
    if (!cmp_write_bool(&cmp_ctx, device->led_red))
    {
      DATABAY_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return DATABAY_ERR_ENCODE;
    }
  }

  // 3: led_green
  if (device->led_green_set)
  {
    if (!cmp_write_u8(&cmp_ctx, 3))
    {
      DATABAY_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return DATABAY_ERR_ENCODE;
    }
    if (!cmp_write_bool(&cmp_ctx, device->led_green))
    {
      DATABAY_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return DATABAY_ERR_ENCODE;
    }
  }

  // 4: uptime
  if (device->uptime_set)
  {
    if (!cmp_write_u8(&cmp_ctx, 4))
    {
      DATABAY_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return DATABAY_ERR_ENCODE;
    }
    if (!cmp_write_integer(&cmp_ctx, device->uptime))
    {
      DATABAY_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return DATABAY_ERR_ENCODE;
    }
  }

  // 5: publish_interval
  if (device->publish_interval_set)
  {
    if (!cmp_write_u8(&cmp_ctx, 5))
    {
      DATABAY_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return DATABAY_ERR_ENCODE;
    }
    if (!cmp_write_integer(&cmp_ctx, device->publish_interval))
    {
      DATABAY_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
      return DATABAY_ERR_ENCODE;
    }
  }

  *out_len = msgpack_buf.offset;
  return DATABAY_OK;
}

// --- DECODE DEVICE ---
databay_result_t databay_device_1000_decode(databay_device_1000_t *device, uint8_t *in, uint8_t in_size)
{
  cmp_ctx_t cmp_ctx = {0};
  databay_msgpack_buffer_t msgpack_buf = {in, 0};

  cmp_init(&cmp_ctx, (void *)&msgpack_buf, databay_device_msgpack_reader, NULL, NULL);

  uint32_t msg_array_size = 0;

  // Main msg array
  if (!cmp_read_array(&cmp_ctx, &msg_array_size) && msg_array_size != 3)
  {
    DATABAY_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
    return DATABAY_ERR_DECODE;
  }

  cmp_object_t obj;

  // Device class id
  if (!cmp_read_object(&cmp_ctx, &obj))
  {
    DATABAY_PRINTF("%s\n", "could not read object");
    return DATABAY_ERR_DECODE;
  }
  if (!cmp_object_as_long(&obj, &device->schema_id))
  {
    DATABAY_PRINTF("%s\n", "could not read schema_id\n");
    return DATABAY_ERR_DECODE;
  }

  // Attributes
  uint32_t attributes_map_len = 0;
  if (!cmp_read_map(&cmp_ctx, &attributes_map_len))
  {
    DATABAY_PRINTF("%s\n", cmp_strerror(&cmp_ctx));
    return DATABAY_ERR_DECODE;
  }

  uint8_t key = 0xFF;
  for (uint16_t i = 0; i < attributes_map_len; ++i)
  {
    // Key
    if (!cmp_read_object(&cmp_ctx, &obj))
    {
      DATABAY_PRINTF("%s\n", "could not read map key");
      return DATABAY_ERR_DECODE;
    }
    if (cmp_object_as_uchar(&obj, &key))
    {
      // Value
      if (!cmp_read_object(&cmp_ctx, &obj))
      {
        DATABAY_PRINTF("%s\n", "could not read attribute value");
        return DATABAY_ERR_DECODE;
      }
      switch (key)
      {
      case 0: // temperature
        if (cmp_read_decimal(&cmp_ctx, &device->temperature))
        {
          device->temperature_set = true;
        }
        else
        {
          DATABAY_PRINTF("%s\n", "could not read value\n");
          return DATABAY_ERR_DECODE;
        }
        break;

      case 1: // button
        if (cmp_object_as_bool(&obj, &device->button))
        {
          device->button_set = true;
        }
        else
        {
          DATABAY_PRINTF("%s\n", "could not read value\n");
          return DATABAY_ERR_DECODE;
        }
        break;

      case 2: // led_red
        if (cmp_object_as_bool(&obj, &device->led_red))
        {
          device->led_red_set = true;
        }
        else
        {
          DATABAY_PRINTF("%s\n", "could not read value\n");
          return DATABAY_ERR_DECODE;
        }
        break;

      case 3: // led_green
        if (cmp_object_as_bool(&obj, &device->led_green))
        {
          device->led_green_set = true;
        }
        else
        {
          DATABAY_PRINTF("%s\n", "could not read value\n");
          return DATABAY_ERR_DECODE;
        }
        break;

      case 4: // uptime
        if (cmp_object_as_long(&obj, &device->uptime))
        {
          device->uptime_set = true;
        }
        else
        {
          DATABAY_PRINTF("%s\n", "could not read value\n");
          return DATABAY_ERR_DECODE;
        }
        break;

      case 5: // publish_interval
        if (cmp_object_as_long(&obj, &device->publish_interval))
        {
          device->publish_interval_set = true;
        }
        else
        {
          DATABAY_PRINTF("%s\n", "could not read value\n");
          return DATABAY_ERR_DECODE;
        }
        break;

      default:
        DATABAY_PRINTF("%s\n", "attribute index out of bounds\n");
        return DATABAY_ERR_DECODE;
      }
    }
    else
    {
      DATABAY_PRINTF("%s\n", "could not read value\n");
      return DATABAY_ERR_DECODE;
    }
  }
  return DATABAY_OK;
}

// --- DISPATCH DEVICE ---
uint8_t databay_device_1000_dispatch(databay_device_1000_t *device)
{
  uint8_t count = 0;
  if (device->on_led_red_update && device->led_red_set)
  {
    device->on_led_red_update(device->led_red);
    ++count;
  }
  if (device->on_led_green_update && device->led_green_set)
  {
    device->on_led_green_update(device->led_green);
    ++count;
  }
  if (device->on_publish_interval_update && device->publish_interval_set)
  {
    device->on_publish_interval_update(device->publish_interval);
    ++count;
  }
  return count;
}

#endif // __DATABAY_DEVICE_1000__
